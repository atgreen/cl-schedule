* cl-schedule-2: a scheduling library in CL

A schedule is a function with a time spec. =cl-schedule-2= calls
the function according to its time spec.

For example, to run a function every hour on the hour,

#+begin_src lisp
(defun print! (str)
  (print! "~a" str)
  (terpri))

(schedule!
 :func (lambda () (print! "Hello!"))
 :time '(:second 0
         :minute 0))
#+end_src

To run a function every day at 8am and 8pm,

#+begin_src lisp
(schedule!
 :func (lambda () (print! "Hello!"))
 :time '(:second 0
         :minute 0
         :hour   (8 20)))
#+end_src

To run a function every 30 seconds from 8am to 6pm,

#+begin_src lisp
(schedule!
 :func (lambda () (print! "Hello!"))
 :time '(:second (0 30)
         :hour   (integer 8 18)))
#+end_src

The previous example shows that =cl-schedule= integrates Common
Lisp type system into its time spec syntax. For a more
sophisticated example, consider the cron time spec
=*/25 5-6,10 * 7 1-3=,

#+begin_src lisp
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(schedule!
 :func (lambda () (print! "Hello!"))
 :time '(:minute (satisfies m-of-25-p)
         :hour (or (integer 5 6) (member 10))
         :month 7
         :day-of-week (integer 0 2))) ; day-of-week (0 1 2 3 4 5 6) means (Mon Tue Wed Thu Fri Sat Sun)
#+end_src

You can prepare the function and time spec elsewhere. For
example, the previous example is equivalent to the following

#+begin_src lisp
(let ((func  (lambda () (print! "Hello!")))
      (time '(:minute (satisfies m-of-25-p)
              :hour (or (integer 5 6) (member 10))
              :month 7
              :day-of-week (integer 0 2))))
  (schedule! :func func :time time))
#+end_src

The time spec does not have to be in the form of such list.
=cl-schedule-2= supports any function with one parameter
(interpreted as the universal time). For example, a function that
runs every 10 seconds:

#+begin_src lisp
(schedule!
 :func (lambda () (print! "Hello!")))
 :time (lambda (time)
         (= 0 (mod (decode-universal-time time) 10)))
#+end_src

A overly complicated example that makes use of this power,

#+begin_src lisp
(defun fibonacci? (n)
  (find n '(0 1 2 3 5 8 13 21 34 55)))

(defparameter *a-complicated-time-spec*
  (lambda (time)
    (multiple-value-bind (second minute hour day month year)
        (decode-universal-time time)
      (and (= 0 second minute)
           (not (= 1 month))
           (fibonacci? (* (+ hour day) month))))))

(schedule!
 :func (lambda () (print! "Hello!"))
 :time *a-complicated-time-spec*)
#+end_src

The function =dry-run= generates the next few times that satisfy
a given time spec. For example,

#+begin_src lisp
(mapcar #'local-time:universal-to-timestamp
        (dry-run '(:second (member 0) ; TODO Remove MEMBER after writing the compiler.
                   :minute (member 0) ; TODO Remove MEMBER after writing the compiler.
                   :hour   (member 8 20)) ; TODO Remove MEMBER after writing the compiler.
        :init  3882950000 ; universal time (@2023-01-17T05:13:20.000000-08:00)
        :range 400000     ; search range   (seconds)
        ))
;; =>
;; (@2023-01-18T08:00:00.000000+08:00
;;  @2023-01-18T20:00:00.000000+08:00
;;  @2023-01-19T08:00:00.000000+08:00
;;  @2023-01-19T20:00:00.000000+08:00
;;  @2023-01-20T08:00:00.000000+08:00
;;  @2023-01-20T20:00:00.000000+08:00
;;  @2023-01-21T08:00:00.000000+08:00
;;  @2023-01-21T20:00:00.000000+08:00
;;  @2023-01-22T08:00:00.000000+08:00)
#+end_src

It works for general time specs too:

#+begin_src lisp
(mapcar #'local-time:universal-to-timestamp
        (dry-run *a-complicated-time-spec*
                 :init  3882950000 ; universal time (@2023-01-17T05:13:20.000000-08:00)
                 :range 2000000    ; search range   (seconds)
                 ))
;; =>
;; (@2023-02-01T00:00:00.000000-08:00
;;  @2023-02-01T03:00:00.000000-08:00
;;  @2023-02-01T16:00:00.000000-08:00
;;  @2023-02-02T02:00:00.000000-08:00
;;  @2023-02-02T15:00:00.000000-08:00
;;  @2023-02-03T01:00:00.000000-08:00
;;  @2023-02-03T14:00:00.000000-08:00
;;  @2023-02-04T00:00:00.000000-08:00
;;  @2023-02-04T13:00:00.000000-08:00
;;  @2023-02-05T12:00:00.000000-08:00
;;  @2023-02-06T11:00:00.000000-08:00
;;  @2023-02-07T10:00:00.000000-08:00
;;  @2023-02-08T09:00:00.000000-08:00
;;  @2023-02-09T08:00:00.000000-08:00)
#+end_src

** TODOs

+ Time spec
  + Documentation.
  + Make it a class for it.
  + type-spec, shortened type-spec, cron style, predicate function

+ Write test cases for the demo'd examples.
+ Pressure Test (I observe that sometimes it skips! Not sure if
  it is because of log4cl. Fire many schedules that run each
  second.)

** FAQ

+ Q. What if a schedule is missed? For example, perhaps the OS is
  asleep when a schedule is meant to be run?

+ A. =cl-schedule-2= does not support re-running or checking the
  schedule. However, it should not be hard to achieve by
  providing functions that remember some information by
  themselves.

+ Q. How to check the history of schedule?

+ A. We will support this soon: the user will be able to check a
  list of times when the schedules have been called by
  =cl-schedule-2=.
