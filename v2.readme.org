* cl-schedule-2: a scheduling library in CL

=cl-schedule= is a scheduling library in common-lisp. It serves as
a replacement of traditional cron managers.

--- TODO Start with a better set of examples. TODO ---

Thanks to richer expressiveness of Lisp, it subsumes what a
traditional cron manager can do. For example, the control string
=*/25 5-6,10 * 7 1-3 /bin/echo Hello, world!= can be expressed as
the following. More examples to come!

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(defun echo (text)
  (uiop:run-program (format nil "echo ~a" text)
                    :output *standard-output*))

(schedule!
 :name "Demo"
 :func (lambda () (echo "Hello, world!"))
 :time '(:minute (satisfies m-of-25-p)
         :hour (or (integer 5 6) (member 10))
         :month 7 ; TODO FIXME WRONG
         :day-of-week (integer 0 2)))
#+end_src

Notice that you can dry-run the schedule (see below) to inspect
the time of the upcoming events. Also notice that in order to
respect the convention of =#'decode-universal-time=, =(0 1 2 3 4 5
6)= means =(Mon Tue Wed Thu Fri Sat Sun)=. In particular, =(0 1 2)=
means =(Mon Tue Wed)=.

** Installation

=cl-schedule= is on [[https://www.quicklisp.org/beta/][Quicklisp]]. To install and start using it,
evaluate the form =(ql:quickload :cl-schedule)= in the repl.

** Examples

*** Basic examples

Here are some easier examples.

#+begin_src common-lisp :eval never
;; 0 */2 * * * echo "Every two hours."
(schedule!
 :name "Demo"
 :func (lambda () (echo "Every two hours."))
 :time '(:hour (satisfies evenp)))

;; 0 20 * * 4 echo "8pm on a Thursday."
(schedule!
 :name "Demo"
 :func (lambda () (echo "8pm on a Thursday."))
 ;; FIXME following is wrong
 :time '(:hour 20 :day-of-week 3))    ; 0 means Mon, 3 means Thu, and 6 means Sun.
#+end_src

*** Finer than cron

=cl-schedule= is strictly finer than cron. In particular, the user
can specify its behavior to each second. For example, to make a
thread that prints the universal time every ten seconds, call the
macro =schedule!= as follows.

#+begin_src common-lisp :eval never
(schedule!
 :name "Demo"
 :func (lambda () (print (get-universal-time)) (terpri))
 :time '(:second (member 0 10 20 30 40 50)))
#+end_src

*** Unschedule the timers

Unschedule all timers.

#+begin_src common-lisp :eval never
(mapc #'unschedule (all-schedules))
#+end_src

*** Dry-run a schedule

It is helpful to inspect the time of the upcoming events. To do
this, we can use the macro =dry-run= to list the time of the
upcoming events. Here is an example that displays for a
complicated schedule.

(Notice that the schedule-definition is equivalent to the control
string =*/25 5-6,10 * 7 1-3= in traditional cron managers.)

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(dry-run 30 '(:minute (satisfies m-of-25-p)
              :hour (or (integer 5 6) (member 10)) ; 5~6 or 10
              :month 7
              :day-of-week (integer 0 2))) ; (0 1 2) means (Mon Tue Wed)
#+end_src

This returns ... (TODO)

** Upcoming feature

*** provide test cases

*** timer inspection

Document the following:

  Let the user interact with the schedule.

  1. Enable and disable the schedule.
  2. Inspect the form, time spec, the next time to be fired.

** FAQ

*** What does it do if the job doesn't finish by the time it's scheduled to run again?

TODO - FIXME check if this section is correct.

---

In that case, =cl-schedule= simply fires that job again on time,
regardless if the old process is still running. If you do not
like this behavior, you can alter the function for it to check if
it has to evaluate its main body. For example, instead of

#+begin_src common-lisp :eval never
(schedule!
 :name "Demo"
 :func (lambda () (echo "Hello, world!"))
 :time '(:minute (satisfies m-of-25-p)))
#+end_src

you can alter the =:FORM= slot

#+begin_src common-lisp :eval never
(schedule!
 :name "Demo"
 :func (lambda () (unless (still-running) (echo "Hello, world!")))
 :time '(:minute (satisfies m-of-25-p)))
#+end_src

Notice that this is just a pseudo-code. The users should write
=(still-running)= by themselves (this should not be hard).

*** Developer Notes

v1 is a rewrite of v0. v1 no longer depends on trivial-timers,
which uses priority queues to schedule timers, making it harder
to pre-schedule a timer at multiple different points of time in
the future. v1 still depends on bordeaux-threads though. It
maintains two global threads, the scheduler and the dispatcher.
It also maintains two global collections, =*schedules*= and
=*actions*=. A schedule is a description of what ..

* New Readme

A schedule is a function with a time spec. =cl-schedule-2= calls
the function according to its time spec. For example, to run a
function every hour on the hour,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second 0
         :minute 0))
#+end_src

To run a function every day at 8am and 8pm,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second 0
         :minute 0
         :hour   (8 20)))
#+end_src

To run a function every 30 seconds from 8am to 6pm,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second (0 30)
         :hour   (integer 8 18)))
#+end_src

The previous example shows that =cl-schedule= integrates Common
Lisp type system into its time spec syntax. For a more
sophisticated example, consider the cron time spec =*/25 5-6,10 *
7 1-3=,

#+begin_src lisp
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:minute (satisfies m-of-25-p)
         :hour (or (integer 5 6) (member 10))
         :month 7
         :day-of-week (integer 0 2))) ; day-of-week (0 1 2 3 4 5 6) means (Mon Tue Wed Thu Fri Sat Sun)
#+end_src

You can prepare the function and time spec elsewhere. For
example, the previous example is equivalent to the following

#+begin_src lisp
(let ((func  (lambda () (format t "Hello!")))
      (time '(:minute (satisfies m-of-25-p)
              :hour (or (integer 5 6) (member 10))
              :month 7
              :day-of-week (integer 0 2))))
  (schedule! :func func :time time))
#+end_src

The time spec does not have to be in the form of such list.
=cl-schedule-2= supports any function with one parameter
(interpreted as the universal time). For example, a function that
runs every 10 seconds:

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!")))
 :time (lambda (time)
         (= 0 (mod (decode-universal-time time) 10)))
#+end_src

A overly complicated example that makes use of this power,

#+begin_src lisp
(defun fibonacci? (n)
  (find n '(0 1 2 3 5 8 13 21 34 55)))

(defparameter *a-complicated-time-spec*
  (lambda (time)
    (multiple-value-bind (second minute hour day month year)
        (decode-universal-time time)
      (and (= 0 second minute)
           (not (= 1 month))
           (fibonaccip (* (+ hour day) month))))))

(schedule!
 :func (lambda () (format t "Hello!"))
 :time *a-complicated-time-spec*)
#+end_src

The function =dry-run= generates the next few times that satisfy
a given time spec. For example,

#+begin_src lisp
(mapcar #'local-time:universal-to-timestamp
        (dry-run *a-complicated-time-spec*
                 :init  3882950000 ; universal time (@2023-01-17T05:13:20.000000-08:00)
                 :range 2000000    ; search range   (seconds)
                 ))
;; =>
;; (@2023-02-01T00:00:00.000000-08:00
;;  @2023-02-01T03:00:00.000000-08:00
;;  @2023-02-01T16:00:00.000000-08:00
;;  @2023-02-02T02:00:00.000000-08:00
;;  @2023-02-02T15:00:00.000000-08:00
;;  @2023-02-03T01:00:00.000000-08:00
;;  @2023-02-03T14:00:00.000000-08:00
;;  @2023-02-04T00:00:00.000000-08:00
;;  @2023-02-04T13:00:00.000000-08:00
;;  @2023-02-05T12:00:00.000000-08:00
;;  @2023-02-06T11:00:00.000000-08:00
;;  @2023-02-07T10:00:00.000000-08:00
;;  @2023-02-08T09:00:00.000000-08:00
;;  @2023-02-09T08:00:00.000000-08:00)
#+end_src

It works for general time specs too.

** TODOs

+ Write test cases for the demo'd examples.
+ Support usual cron time spec syntax, by compiling it into our
  spec syntax (in terms of CL type spec).
+ Implement feature: the user will be able to check a list of
  times when the schedules have been called by =cl-schedule-2=.
+ Implement feature: List all enabled schedules.
+ Implement feature: If name is empty, generate a unique name.
+ Implement feature: Each schedule must have a name. And no
  schedules on the global queue =*schedules*= can have the same
  name (=#'equal=).
+ Implement feature: =#'print-schedules-info=.
+ Implement feature: =#'next-registered-shots (schedule)=.
+ Implement feature: =#'dry-run (schedule)=.
+ Provide example: Check every =1= hour if a certain service is
  still alive.
+ Document time spec, and which are compiled to which: function
  (general), CL type-spec style, shortened CL type-spec style
  (shorthand), cron style (unsupported yet).
+ schedule! vs schedule: (schedule (make-schedule .. etc)).

** FAQ

+ Q. What if a schedule is missed? For example, perhaps the OS is
  asleep when a schedule is meant to be run?

+ A. =cl-schedule-2= does not support re-running or checking the
  schedule. However, it should not be hard to achieve by
  providing functions that remember some information by
  themselves.

+ Q. How to check the history of schedule?

+ A. We will support this soon: the user will be able to check a
  list of times when the schedules have been called by
  =cl-schedule-2=.
