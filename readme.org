* Clon: A cron-like scheduling library

Clon is a cron-like scheduling library in common-lisp. It
subsumes and replaces traditional cron managers thanks to richer
expressiveness of Lisp.

Thanks to the expressiveness of clon, it subsumes what a
traditional cron manager can do. In particular, in an example
below we show how to make a =schedule= that does what a traditional
cron manager would do for the control string =*/25 5-6,10 * 7 1-2=.
Long story short, it can be expressed as the following.

#+begin_src common-lisp :eval never
(make-typed-cron-schedule
 :minute '(satisfies twenty-five-p)
 :hour '(or (integer 5 6) (member 10))
 :month 7
 :day-of-week '(integer 0 1))
#+end_src

Related projects are [[https://github.com/tsikov/clerk][tsikov's clerk]] and [[https://github.com/ciel-lang/cl-cron/blob/master/cl-cron.lisp][ciel-lang's cl-cron]].
However, to my best knowledge clon is more comprehensive.

** Examples

*** 1. Basic example

To make a thread that prints the universal time every ten
seconds, call the following.

#+begin_src common-lisp :eval never
(let* (;; create a stateless schedule
       (schedule (make-typed-cron-schedule
                  :second '(member 0 10 20 30 40 50)))
       ;; create a scheduler that remembers the last scheduled time
       (scheduler (make-scheduler schedule)))
  ;; schedule a function as a timer
  (schedule-function (lambda ()
                       (print (get-universal-time)))
                     scheduler))
#+end_src

Unschedule the timer returned by =SCHEDULE-FUNCTION=.

#+begin_src common-lisp :eval never
(trivial-timers:unschedule-timer *)
#+end_src

Unschedule all timers.

#+begin_src common-lisp :eval never
(mapc #'trivial-timers:unschedule-timer
      (trivial-timers:list-all-timers))
#+end_src

*** 2. Display times generated by a schedule

This example shows how to dry-run a schedule and see what times
it generates. We use the common-lisp system =local-time=.

#+begin_src common-lisp :eval never
(let ((schedule (make-typed-cron-schedule
                 :second '(member 29 59))))
  (let ((next-time (next-time schedule)))
    (dotimes (x 8)
      (format t "~s~%" (local-time:universal-to-timestamp next-time))
      (setf next-time (next-time schedule :init-time next-time)))
#+end_src

#+begin_src
@2021-05-12T18:57:59.000000+08:00
@2021-05-12T18:58:29.000000+08:00
@2021-05-12T18:58:59.000000+08:00
@2021-05-12T18:59:29.000000+08:00
@2021-05-12T18:59:59.000000+08:00
@2021-05-12T19:00:29.000000+08:00
@2021-05-12T19:00:59.000000+08:00
@2021-05-12T19:01:29.000000+08:00
#+end_src

*** 3. Traditional cron-expression in CLON

To express a traditional cron-expression in =CLON=, consider the
example =*/25 5-6,10 * 7 1-2=. This means that the process should
run every 25 minutes in an hour, and when it is 5, 6, or 10
o'clock, and when it is July, and when it is Monday or Tuesday.
Such expression is given in the definition of =schedule= below. We
use the technique in the example above to display and check its
validity.

#+begin_src common-lisp :eval never
(defun twenty-five-p (n) (eql 0 (mod n 25)))
(let ((schedule (make-typed-cron-schedule
                 :minute '(satisfies twenty-five-p)
                 :hour '(or (integer 5 6) (member 10))
                 :month 7
                 :day-of-week '(integer 0 1))))
  (let ((next-time (next-time schedule)))
    (dotimes (x 30)
      (format t "~s~%" (local-time:universal-to-timestamp next-time))
      (setf next-time (next-time schedule :init-time next-time)))))
#+end_src

#+begin_src
@2021-07-05T05:00:00.000000+05:00
@2021-07-05T05:25:00.000000+05:00
@2021-07-05T05:50:00.000000+05:00
@2021-07-05T06:00:00.000000+05:00
@2021-07-05T06:25:00.000000+05:00
@2021-07-05T06:50:00.000000+05:00
@2021-07-05T10:00:00.000000+05:00
@2021-07-05T10:25:00.000000+05:00
@2021-07-05T10:50:00.000000+05:00
@2021-07-06T05:00:00.000000+05:00
@2021-07-06T05:25:00.000000+05:00
@2021-07-06T05:50:00.000000+05:00
@2021-07-06T06:00:00.000000+05:00
@2021-07-06T06:25:00.000000+05:00
@2021-07-06T06:50:00.000000+05:00
@2021-07-06T10:00:00.000000+05:00
@2021-07-06T10:25:00.000000+05:00
@2021-07-06T10:50:00.000000+05:00
@2021-07-12T05:00:00.000000+05:00
@2021-07-12T05:25:00.000000+05:00
@2021-07-12T05:50:00.000000+05:00
@2021-07-12T06:00:00.000000+05:00
@2021-07-12T06:25:00.000000+05:00
@2021-07-12T06:50:00.000000+05:00
@2021-07-12T10:00:00.000000+05:00
@2021-07-12T10:25:00.000000+05:00
@2021-07-12T10:50:00.000000+05:00
@2021-07-13T05:00:00.000000+05:00
@2021-07-13T05:25:00.000000+05:00
@2021-07-13T05:50:00.000000+05:00
#+end_src

*** 4.

If this runs under =SLIME= you may have to look into the
=*inferior-lisp*= buffer to see the output depending on your setup.

#+begin_src common-lisp :eval never
(let ((n 0))
  (defun say-hello ()
    (incf n)
    (format t "Hello world ~D at ~S~%" n
            (multiple-value-list (decode-universal-time (get-universal-time))))
    (force-output)))
#+end_src

=SCHEDULE= is not mutated by iterating over it by =NEXT-TIME=. A
=SCHEDULER= on the other hand is all about remembering the last
time. The schedule here reads as: 'seconds 0, 15, 30 and 45 of
every even minute that's between 10 and 40'.

#+begin_src common-lisp :eval never
(let ((schedule (clon:make-typed-cron-schedule
                 :second '(member 0 15 30 45)
                 :minute '(and (integer 10 40) (satisfies evenp)))))
  (clon:schedule-function 'say-hello
                          (clon:make-scheduler schedule)
                          :name "Hello world 1"
                          :thread t))
#+end_src

=SCHEDULE-FUNCTION= returned a timer, stop it when we got bored of
it.

#+begin_src common-lisp :eval never
(sb-ext:unschedule-timer *)
#+end_src

*** 5.

Do something even more simple: say hello once every minute. Note
that the first one will happen immediately (thanks to
=ALLOW-NOW-P=) while the subsequent ones at second 0.

#+begin_src common-lisp :eval never
(let ((schedule (clon:make-typed-cron-schedule :minute '*)))
  (clon:schedule-function 'say-hello
                          (clon:make-scheduler schedule :allow-now-p t)
                          :name "Hello world 2"
                          :thread t))
#+end_src

Let's do something moderately fancy. Take second 0 and 15 in even
minutes and second 30 in odd minutes.

#+begin_src common-lisp :eval never
(defun bump-second (second decoded-time n)
  ;; Check that we are indeed the bumper of seconds.
  (assert (= n 0))
  ;; Be painfully correct and return NIL if there is no next second in
  ;; this minute that we want.
  (cond ((oddp (elt decoded-time 1)) 30)
        ((< 15 second) nil)
        ((< 0 second) 15)
        (t 0))
  ;; Or rely on the fact that values less than the current SECOND are
  ;; treated as NIL.
  #+nil
  (cond ((oddp (elt decoded-time 1)) 30)
        ((<= 15) 15)
        (t 0)))

(let ((schedule (clon:make-cron-schedule :second 'bump-second)))
  (clon:schedule-function 'say-hello
                          (clon:make-scheduler schedule)
                          :name "Hello world 3"
                          :thread t))
#+end_src

Unschedule all timers.

#+begin_src common-lisp :eval never
(mapc #'trivial-timers:unschedule-timer
      (trivial-timers:list-all-timers))
#+end_src

** TODOs [2/4]

1. [X] Extend so that it only emits warnings for skipped actions.
   Also create an option for the next call to be immediate if
   skipped.

2. [X] Better documentation. In particular, teaches the user how
   to express cron expressions like =*/5 7 12 * *= in this package.

3. [ ] Document =new/schedule-function= and merge it into
   =schedule-function=, without breaking backward compatibility.

4. [ ] Integrate with jin's =service= utilities, and replace
   =systemd.timer=.
