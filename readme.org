* Clon: A cron-like scheduling library

Clon is a cron-like scheduling library in common-lisp. It serves
as a replacement of traditional cron managers.

Thanks to richer expressiveness of Lisp, it subsumes what a
traditional cron manager can do. For example, the control string
=*/25 5-6,10 * 7 1-3 /bin/echo Hello, world!= can be expressed as
the following

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(schedule-lambda
 :name "Demo"
 :form ((sb-ext:run-program
         "/bin/echo"
         '("Hello, world!")
         :output *standard-output*))
 :time (:minute '(satisfies m-of-25-p)
        :hour '(or (integer 5 6) (member 10))
        :month 7
        :day-of-week '(integer 0 2) ; (0 1 2) means (Mon Tue Wed)
                ))
#+end_src

** Examples

*** Basic examples

Here are some easier examples.

#+begin_src common-lisp :eval never
;; 0 */2 * * * echo "Every two hours."
(schedule-lambda
 :name "Demo"
 :form ((sb-ext:run-program
         "/bin/echo"
         '("Every two hours.")
         :output *standard-output*))
 :time (:hour '(satisfies evenp)))

;; 0 20 * * 4 echo "8pm on a Thursday."
(schedule-lambda
 :name "Demo"
 :form ((sb-ext:run-program
         "/bin/echo"
         '("8pm on a Thursday")
         :output *standard-output*))
 :time (:hour 20
        :day-of-week 3               ; 0 means Mon; 3 means Thu.
              ))
#+end_src

*** Finer than cron

Clon is strictly finer than cron. In particular, the user can
specify its behavior to each second. For example, to make a
thread that prints the universal time every ten seconds, call the
macro =schedule-lambda= as follows.

#+begin_src common-lisp :eval never
(schedule-lambda
 :name "demo"
 :form ((print (get-universal-time)))
 :time (:second '(member 0 10 20 30 40 50)))
#+end_src

*** Unschedule the timers

Unschedule all timers.

#+begin_src common-lisp :eval never
(mapc #'trivial-timers:unschedule-timer
      (trivial-timers:list-all-timers))
#+end_src

*** Dry-run a schedule

It is helpful to inspect the time of the upcoming events. To do
this, we can use the macro =dry-run= to list the time of the
upcoming events. Here is an example that displays for a
complicated schedule.

(Notice that the schedule-definition is equivalent to the control
string =*/25 5-6,10 * 7 1-3= in traditional cron managers.)

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(dry-run 30 ; display the next 30 instances
         (:minute '(satisfies m-of-25-p)
          :hour '(or (integer 5 6) (member 10))
          :month 7
          :day-of-week '(integer 0 2) ; (0 1 2) means (Mon Tue Wed)
                  ))
#+end_src

This prints the following to =*standard-output*=.

#+begin_src text
;; Ran in May 2021.
@2021-07-05T05:00:00.000000+08:00 ;; Monday
@2021-07-05T05:25:00.000000+08:00
@2021-07-05T05:50:00.000000+08:00
@2021-07-05T06:00:00.000000+08:00
@2021-07-05T06:25:00.000000+08:00
@2021-07-05T06:50:00.000000+08:00
@2021-07-05T10:00:00.000000+08:00
@2021-07-05T10:25:00.000000+08:00
@2021-07-05T10:50:00.000000+08:00
@2021-07-06T05:00:00.000000+08:00 ;; Tuesday
@2021-07-06T05:25:00.000000+08:00
@2021-07-06T05:50:00.000000+08:00
@2021-07-06T06:00:00.000000+08:00
@2021-07-06T06:25:00.000000+08:00
@2021-07-06T06:50:00.000000+08:00
@2021-07-06T10:00:00.000000+08:00
@2021-07-06T10:25:00.000000+08:00
@2021-07-06T10:50:00.000000+08:00
@2021-07-07T05:00:00.000000+08:00 ;; Wednesday
@2021-07-07T05:25:00.000000+08:00
@2021-07-07T05:50:00.000000+08:00
@2021-07-07T06:00:00.000000+08:00
@2021-07-07T06:25:00.000000+08:00
@2021-07-07T06:50:00.000000+08:00
@2021-07-07T10:00:00.000000+08:00
@2021-07-07T10:25:00.000000+08:00
@2021-07-07T10:50:00.000000+08:00
@2021-07-12T05:00:00.000000+08:00 ;; Monday
@2021-07-12T05:25:00.000000+08:00
@2021-07-12T05:50:00.000000+08:00
#+end_src

** Related Projects

Some related projects are [[https://github.com/tsikov/clerk][tsikov's clerk]] and [[https://github.com/ciel-lang/cl-cron/blob/master/cl-cron.lisp][ciel-lang's cl-cron]].
However, to my best knowledge clon is more comprehensive.
