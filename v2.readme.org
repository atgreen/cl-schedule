* cl-schedule-2: a scheduling library in CL

A schedule is a function with a time spec. =cl-schedule-2= calls
the function according to its time spec. For example, to run a
function every hour on the hour,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second 0
         :minute 0))
#+end_src

To run a function every day at 8am and 8pm,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second 0
         :minute 0
         :hour   (8 20)))
#+end_src

To run a function every 30 seconds from 8am to 6pm,

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:second (0 30)
         :hour   (integer 8 18)))
#+end_src

The previous example shows that =cl-schedule= integrates Common
Lisp type system into its time spec syntax. For a more
sophisticated example, consider the cron time spec =*/25 5-6,10 *
7 1-3=,

#+begin_src lisp
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(schedule!
 :func (lambda () (format t "Hello!"))
 :time '(:minute (satisfies m-of-25-p)
         :hour (or (integer 5 6) (member 10))
         :month 7
         :day-of-week (integer 0 2))) ; day-of-week (0 1 2 3 4 5 6) means (Mon Tue Wed Thu Fri Sat Sun)
#+end_src

You can prepare the function and time spec elsewhere. For
example, the previous example is equivalent to the following

#+begin_src lisp
(let ((func  (lambda () (format t "Hello!")))
      (time '(:minute (satisfies m-of-25-p)
              :hour (or (integer 5 6) (member 10))
              :month 7
              :day-of-week (integer 0 2))))
  (schedule! :func func :time time))
#+end_src

The time spec does not have to be in the form of such list.
=cl-schedule-2= supports any function with one parameter
(interpreted as the universal time). For example, a function that
runs every 10 seconds:

#+begin_src lisp
(schedule!
 :func (lambda () (format t "Hello!")))
 :time (lambda (time)
         (= 0 (mod (decode-universal-time time) 10)))
#+end_src

A overly complicated example that makes use of this power,

#+begin_src lisp
(defun fibonacci? (n)
  (find n '(0 1 2 3 5 8 13 21 34 55)))

(defparameter *a-complicated-time-spec*
  (lambda (time)
    (multiple-value-bind (second minute hour day month year)
        (decode-universal-time time)
      (and (= 0 second minute)
           (not (= 1 month))
           (fibonaccip (* (+ hour day) month))))))

(schedule!
 :func (lambda () (format t "Hello!"))
 :time *a-complicated-time-spec*)
#+end_src

The function =dry-run= generates the next few times that satisfy
a given time spec. For example,

#+begin_src lisp
(mapcar #'local-time:universal-to-timestamp
        (dry-run *a-complicated-time-spec*
                 :init  3882950000 ; universal time (@2023-01-17T05:13:20.000000-08:00)
                 :range 2000000    ; search range   (seconds)
                 ))
;; =>
;; (@2023-02-01T00:00:00.000000-08:00
;;  @2023-02-01T03:00:00.000000-08:00
;;  @2023-02-01T16:00:00.000000-08:00
;;  @2023-02-02T02:00:00.000000-08:00
;;  @2023-02-02T15:00:00.000000-08:00
;;  @2023-02-03T01:00:00.000000-08:00
;;  @2023-02-03T14:00:00.000000-08:00
;;  @2023-02-04T00:00:00.000000-08:00
;;  @2023-02-04T13:00:00.000000-08:00
;;  @2023-02-05T12:00:00.000000-08:00
;;  @2023-02-06T11:00:00.000000-08:00
;;  @2023-02-07T10:00:00.000000-08:00
;;  @2023-02-08T09:00:00.000000-08:00
;;  @2023-02-09T08:00:00.000000-08:00)
#+end_src

It works for general time specs too.

** TODOs

+ Write test cases for the demo'd examples.
+ Support usual cron time spec syntax, by compiling it into our
  spec syntax (in terms of CL type spec).
+ Implement feature: the user will be able to check a list of
  times when the schedules have been called by =cl-schedule-2=.
+ Implement feature: List all enabled schedules.
+ Implement feature: If name is empty, generate a unique name.
+ Implement feature: Each schedule must have a name. And no
  schedules on the global queue =*schedules*= can have the same
  name (=#'equal=).
+ Implement feature: =#'print-schedules-info=.
+ Implement feature: =#'next-registered-shots (schedule)=.
+ Implement feature: =#'dry-run (schedule)=.
+ Provide example: Check every =1= hour if a certain service is
  still alive.
+ Document time spec, and which are compiled to which: function
  (general), CL type-spec style, shortened CL type-spec style
  (shorthand), cron style (unsupported yet).
+ schedule! vs schedule: (schedule (make-schedule .. etc)).

** FAQ

+ Q. What if a schedule is missed? For example, perhaps the OS is
  asleep when a schedule is meant to be run?

+ A. =cl-schedule-2= does not support re-running or checking the
  schedule. However, it should not be hard to achieve by
  providing functions that remember some information by
  themselves.

+ Q. How to check the history of schedule?

+ A. We will support this soon: the user will be able to check a
  list of times when the schedules have been called by
  =cl-schedule-2=.
