* cl-schedule: a scheduling library in CL

=cl-schedule= is a scheduling library in common-lisp. It serves as
a replacement of traditional cron managers.

Thanks to richer expressiveness of Lisp, it subsumes what a
traditional cron manager can do. For example, the control string
=*/25 5-6,10 * 7 1-3 /bin/echo Hello, world!= can be expressed as
the following. More examples to come!

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(defun echo (text)
  (uiop:run-program (format nil "echo ~a" text)
                    :output *standard-output*))

(schedule!
 :name "Demo"
 :form ((echo "Hello, world!"))
 :time (:minute '(satisfies m-of-25-p)
        :hour '(or (integer 5 6) (member 10))
        :month 7
        :day-of-week '(integer 0 2)))
#+end_src

[[http://clhs.lisp.se/Body/04_bc.htm][Common Lisp's type specifiers]] are used as the DSL to specify the
time slot. This enables the user to control the time-spec with
freedom [[https://cl-su-ai.cddddr.org/msg01196.html][(1)]].

Notice that you can dry-run the schedule (see below) to inspect
the time of the upcoming events. Also notice that in order to
respect the convention of =#'decode-universal-time=, =(0 1 2 3 4 5
6)= means =(Mon Tue Wed Thu Fri Sat Sun)=. In particular, =(0 1 2)=
means =(Mon Tue Wed)=.

** Examples

*** Basic examples

Here are some easier examples.

#+begin_src common-lisp :eval never
;; 0 */2 * * * echo "Every two hours."
(schedule!
 :name "Demo"
 :form ((echo "Every two hours."))
 :time (:hour '(satisfies evenp)))

;; 0 20 * * 4 echo "8pm on a Thursday."
(schedule!
 :name "Demo"
 :form ((echo "8pm on a Thursday."))
 :time (:hour 20 :day-of-week 3))    ; 0 means Mon, 3 means Thu, and 6 means Sun.
#+end_src

*** Finer than cron

=cl-schedule= is strictly finer than cron. In particular, the user
can specify its behavior to each second. For example, to make a
thread that prints the universal time every ten seconds, call the
macro =schedule!= as follows.

#+begin_src common-lisp :eval never
(schedule!
 :name "demo"
 :form ((print (get-universal-time)))
 :time (:second '(member 0 10 20 30 40 50)))
#+end_src

*** Unschedule the timers

Unschedule all timers.

#+begin_src common-lisp :eval never
(mapc #'trivial-timers:unschedule-timer
      (trivial-timers:list-all-timers))
#+end_src

*** Dry-run a schedule

It is helpful to inspect the time of the upcoming events. To do
this, we can use the macro =dry-run= to list the time of the
upcoming events. Here is an example that displays for a
complicated schedule.

(Notice that the schedule-definition is equivalent to the control
string =*/25 5-6,10 * 7 1-3= in traditional cron managers.)

#+begin_src common-lisp :eval never
(defun m-of-25-p (n) (eql 0 (mod n 25)))
(let ((time-spec '(:minute (satisfies m-of-25-p)
                   :hour (or (integer 5 6) (member 10)) ; 5~6 or 10
                   :month 7
                   :day-of-week (integer 0 2)))) ; (0 1 2) means (Mon Tue Wed)
  (dry-run 30 time-spec)); display the next 30 instances
#+end_src

This prints the following to =*standard-output*=.

#+begin_src text
;; Ran in May 2021.
@2021-07-05T05:00:00.000000+08:00 ;; Monday
@2021-07-05T05:25:00.000000+08:00
@2021-07-05T05:50:00.000000+08:00
@2021-07-05T06:00:00.000000+08:00
@2021-07-05T06:25:00.000000+08:00
@2021-07-05T06:50:00.000000+08:00
@2021-07-05T10:00:00.000000+08:00
@2021-07-05T10:25:00.000000+08:00
@2021-07-05T10:50:00.000000+08:00
@2021-07-06T05:00:00.000000+08:00 ;; Tuesday
@2021-07-06T05:25:00.000000+08:00
@2021-07-06T05:50:00.000000+08:00
@2021-07-06T06:00:00.000000+08:00
@2021-07-06T06:25:00.000000+08:00
@2021-07-06T06:50:00.000000+08:00
@2021-07-06T10:00:00.000000+08:00
@2021-07-06T10:25:00.000000+08:00
@2021-07-06T10:50:00.000000+08:00
@2021-07-07T05:00:00.000000+08:00 ;; Wednesday
@2021-07-07T05:25:00.000000+08:00
@2021-07-07T05:50:00.000000+08:00
@2021-07-07T06:00:00.000000+08:00
@2021-07-07T06:25:00.000000+08:00
@2021-07-07T06:50:00.000000+08:00
@2021-07-07T10:00:00.000000+08:00
@2021-07-07T10:25:00.000000+08:00
@2021-07-07T10:50:00.000000+08:00
@2021-07-12T05:00:00.000000+08:00 ;; Monday
@2021-07-12T05:25:00.000000+08:00
@2021-07-12T05:50:00.000000+08:00
#+end_src

** Upcoming feature

*** cron syntax

Support cron syntax directly. See =./scr/cron-to-lisp.lisp= for a
detailed plan. Hopefully this will let =cl-schedule= to
(lisp-expressively) replace [[https://github.com/endsec/scheduler][scheduler]] completely (modulo the
randomness supported there).

*** integration with service

Wrap the functions run by =cl-schedule= with some logging facility
by other tools (e.g. [[https://github.com/melisgl/journal#x-28JOURNAL-3AJOURNAL-20CLASS-29][journal]]), and set the slot =:init-time= to the
last running time. This allows skipped schedules be warned and
run. The end result is a schedule in which an
once-every-five-month task makes sense on a machine that shuts
down every day. Hopefully, this will make =cl-schedule= as an
alternative to =systemd.timer=.

*** timer inspection

Let the user inspect, pause, halt, restart the timers set by
=cl-scheduler= in a more native way.

** FAQ

*** What does it do if the job doesn't finish by the time it's scheduled to run again?

In that case, =cl-schedule= simply fires that job again on time,
regardless if the old process is still running. If you do not
like this behavior, you can alter the function for it to check if
it has to evaluate its main body. For example, instead of

#+begin_src common-lisp :eval never
(schedule!
 :name "Demo"
 :form ((echo "Hello, world!"))
 :time (:minute '(satisfies m-of-25-p)))
#+end_src

you can alter the =:FORM= slot

#+begin_src common-lisp :eval never
(schedule!
 :name "Demo"
 :form ((unless (still-running) (echo "Hello, world!")))
 :time (:minute '(satisfies m-of-25-p)))
#+end_src

Notice that this is just a pseudo-code. The users should write
=(still-running)= by themselves (this should not be hard).
